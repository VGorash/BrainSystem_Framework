# VG BrainSystem Framework
Данный фреймворк предназначен для создания собственных брейн-систем. Он реализует логику игры, позволяя при этом абстрагироваться от аппаратной реализации системы 

## Архитектура 
Фреймворк состоит из трёх основных частей:

1. `Engine` - основной класс, точка входа, управляет остальными классами фреймворка
2. `Hal` - слой аппаратной абстракции. Во фреймворке представлен интерфейсом `IHal`, который необходимо реализовать для конкретной системы 
3. `App` - приложение. Реализует целевую логику. Во фреймворке представлен интерфейсом `IApp` и реализациями `Game` (игра без отсчёта), `JeopardyGame` (своя игра) и `BrainRingGame` (брейн ринг)

Все классы фреймворка находятся в пространстве имен vgs

## Общие принципы
Все функции и методы во фреймворке являются неблокирующими, то есть сразу отдают управление. 
Методы `tick()` нужно вызывать как можно чаще, поэтому крайне не рекомендуется использовать какие-либо внешние блокирующие функции (`delay()` в среде Arduino). Использование блокирующих функций может негативно повлиять на работу таймеров.

## Готовые реализации игр
Реализованы три типа игры:

 1. Без отсчета. Только фиксация нажатий. Класс `Game`.
 2. Своя игра. Отсчет 7 секунд (по умолчанию). Класс `JeopardyGame`.
 3. Брейн-ринг. Отсчет 60 секунд (по умолчанию) и 20 при запуске после нажатия без сброса. Класс `BrainRingGame`.

Все игры имеют конструктор с одним параметром - `const GameConfig& config`. Если параметры времени не заданы (меньше нуля), игра инициализирует их сама значениями по умолчанию.

    struct GameTime // настройки времени
    {
      int primary = -1; // длительность основного режима, секунды (СИ (7) и БР (60))
      int secondary = -1; // длительность второго режима, секунды (только БР (20))
    };
    
    enum class GameMode // режим игры
    {
      Normal, // без фальстартов
      Falstart // с фальстартами
    };
    
    struct GameConfig
    {
      const char* displayed_name; // имя игры
      GameMode mode; // режим
      GameTime time; // настройки времени
    };

## Простейший пример работы
Данный пример показан для среды Arduino. Подразумевается, что HalImpl - это реализация интерфейса IHal. Запускается своя игра без фальстартов. Приложение меню не задано, это означает, что смена игры в данной конфигурации невозможна.

    using namespace vgs;
    
    GameConfig config;
	config.displayed_name = "СВОЯ ИГРА";
	config.mode = GameMode::Normal;
    
    Engine engine(new HalImpl(), new JeopardyGame(config), nullptr);
    
    void  setup() 
    {
		engine.init();
	}
	
	void  loop() 
	{
		engine.tick();
	}

## Класс Engine

Класс `Engine` целиком реализован и в базовом сценарии использования не требует модификаций.

### Конструктор

- `Engine(IHal* hal, IApp* initialApp, IApp* menuApp)`

Аргументы конструктора:
1. `IHal* hal` - указатель на экземпляр класса аппаратной абстракции. 
2. `IApp* initialApp` - указатель на приложение, которое будет запущено при старте. Может быть `nullptr`, в этом случае по умолчанию запускается приложение меню
3. `IApp* menuApp` - указатель на приложение меню (то приложение, которое открывается при выходе из любого другого). Если этот аргумент равен `nullptr` выход будет игнорироваться, что может привести к нежелательным последствиям.

**ВНИМАНИЕ, экземпляры (hal и два app), переданные в конструктор, будут уничтожены при уничтожении Engine или в процессе работы. Нельзя использовать эти указатели вне engine!**

В случае, если одновременно обе функции создания приложений не определены, система работать не будет.

### Методы

- `void init()` - инициализация. Метод вызывается один раз при старте системы. При вызове метода последовательно выполняются следующие действия:

	1. Вызывается `init()` у HAL
	2. Вызывается `init()` у приложений (initial и menu)

- `void tick()` - шаг выполнения. Должен вызываться постоянно в цикле (`loop()` в среде Arduino). При вызове этого метода выполняются следующие действия:

	1. Вызывается `tick()` у HAL
	2. Вызывается `tick()` у текущего приложения 
	3. Вызывается метод `appChangeNeeded()` у текущего приложения. 
	4. Если возвращается `AppChangeType::None`, выполнение метода завершается (готов к новому `tick()`)
	5. Если возвращается `AppChangeType::Menu`, текущее приложение (если это не menu) уничтожается. Текущим становится menu app. Если при создании menu было не определено, данный шаг игнорируется (в этом случае поведение аналогично предыдущему пункту)
	6. Если возвращается `AppChangeType::Custom`, у текущего приложения вызывается метод `getCustomApp()`, его результат становится текущим приложением. Далее предыдущее приложение (если это не menu) уничтожается.

## Интерфейс IHal
Интерфейс представляет собой слой аппаратной абстракции. Вызовы его методов используются приложениями для взаимодействия с системой. Подразумевается, что все методы являются неблокирующими (сразу возвращают управление).

### Основные методы
- `void init()` - инициализация класса. Вызывается при инициализации `Engine`

- `void tick()` - шаг выполнения. Вызывается при `tick()` `Engine`

### Работа с кнопками
- `ButtonState getButtonState()` - получение состояния кнопок. Вызывается внутри приложений.

Структура ButtonState представляет собой виртуальное представление кнопок. В общей модели системы подразумеваются 4 основных кнопки управления, неограниченное количество пользовательских кнопок управления (при этом нажата может быть только одна) и неограниченное количество кнопок игроков (нажата в каждый момент времени также может быть только одна).

    struct ButtonState
    {
      bool start = false; // кнопка старта
      bool stop = false; // кнопка остановки/отмены
      bool enter = false; // кнопка ввода/подтверждения
      bool menu = false; // кнопка выхода в меню
      int custom = -1; // номер пользовательской кнопки управления (с 0)
      int player = -1; // номер кнопки игрока (с 0, -1 без нажатий)
    };

### Работа со светодиодами
- `void playerLedOn(int player)` - зажечь светодиод игрока. Номер может быть любым, но в существующих играх номер меньше 0 игнорируется. Обычно метод вызывается при правильном нажатии игрока

- `void playerLedBlink(int player)` - зажечь светодиод игрока в мигающем режиме. Обычно метод вызывается при фальстарте

- `void signalLedOn()` - зажечь сигнал. Обычно вызывается при запуске системы.

- `ledsOff()` - погасить все светодиоды

### Работа со звуком

- `void sound(HalSound soundType)` - проиграть один из предустановленных звуков.

	    enum class HalSound
	    {
	      Start,// звук старта системы
	      Press, // звук при правильном нажатии
	      Falstart, // звук при фальстарте
	      Tick,// звук при отсчете времени на последних секундах
	      Signal,// звук перед последними секундами (в брейне за 10 секунд)
	      End, // звук при окончании времени
	      None // отсутствие (выключение) звука
	    };

- `void sound(unsigned int frequency, unsigned int duration)` - проиграть звук определенной частоты и определенной продолжительности
`frequency` - частота в герцах
`duration` - время в миллисекундах

### Работа с дисплеем
Возможны два варианта обновления дисплея:

 1. Игровой - информация об игре
 2. Пользовательский - любая информация

- `void updateDisplay(const GameDisplayInfo& info)` - обновление в игровом режиме. Только этот метод вызывают игры.

	    enum class GameState // состояние игры
	    {
	      Idle, // ожидание (система не запущена)
	      Countdown, // отсчет (система запущена)
	      Press, // нажатие (игрок нажал кнопку правильно)
	      Falstart // фальстарт
	    };
	    
	    enum class GameMode // режим игры
	    {
	      Normal, // без фальстартов
	      Falstart // с фальстартами
	    };
	    
	    struct GameDisplayInfo
	    {
	      const char* name = ""; // имя игры
	      GameMode mode = GameMode::Normal; // режим игры
	      GameState state = GameState::Idle; // состояние игры
	      int gameTime = -1; // время отсчета
	      int pressTime = -1; // врямя нажатия
	      int player = -1; // нажавший игрок
	      const char* custom = ""; // пользовательское поле (в текущих играх не используется)
	    };

- `void updateDisplay(const CustomDisplayInfo& info)` - обновление в пользовательском режиме. Может использоваться для вывода произвольной информации. Играми не вызывается.

	    struct CustomDisplayInfo
	    {
	      int type = -1; // идентификатор
	      const void* data = nullptr; // указатель на произвольные данные
	    };

### Работа со временем
- `unsigned long getTimeMillis()` - получить текущее системное время в миллисекундах

## Интерфейс IApp
Данный интерфейс представляет приложение (игру), запускаемое на системе. Интерфейс реализуют встроенные игры. Таже можно самостоятельно реализовать интерфейс для создания собственных игр.

### Методы
- `void init(IHal& hal)` - инициализация. Вызывается после создания

- `void tick(IHal& hal)` - шаг выполнения. Вызывается при `tick()` `Engine`

- `AppChangeType appChangeNeeded()` - проверка, нужен ли выход из приложения.

	    enum class AppChangeType
	    {
	      None, // выход не нужен
	      Menu, // выход и открытие меню (настроек)
	      Custom // выход и создание пользовательского приложения
	    };

- `IApp* createCustomApp()` - создание пользовательского приложения при `AppChangeType::Custom`

## Таймер
Фреймворк содержит реализацию таймера, который может быть полезен для работы со временем как в играх (отсчет времени), так и внутри HAL (например, для регулирования периода мигания светодиода).

### Конструктор
- `Timer(unsigned long time = 1000, bool periodMode = false)`
`time` - время в миллисекундах
`periodMode` - периодический режим (автоматический перезапуск после окончания времени)

### Методы
- `void setTime(unsigned long time)` - установка времени в миллисекундах

- `void setPeriodMode(bool mode)` - установка периодического режима

- `void start(const IHal& hal)` - запуск таймера (передается ссылка на HAL)

- `void stop()` - остановка таймера

- `bool isStarted()` - проверка, запущен ли таймер
